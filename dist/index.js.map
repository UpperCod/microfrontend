{"version":3,"file":"index.js","sources":["../node_modules/atomico/chunk/constants.js","../node_modules/atomico/chunk/utils.js","../node_modules/atomico/core.js","../src/microfront/microfront.js","../src/microfront/preact.js","../src/index.js"],"sourcesContent":["const HOOK_MOUNT = Symbol(\"mount\");\r\nconst HOOK_MOUNTED = Symbol(\"mounted\");\r\nconst HOOK_UPDATE = Symbol(\"update\");\r\nconst HOOK_UPDATED = Symbol(\"updated\");\r\nconst HOOK_UNMOUNT = Symbol(\"unmount\");\r\nconst HOOK_CURRENT = {};\r\n\r\nconst ELEMENT_PROPS = Symbol(\"props\");\r\nconst ELEMENT_IGNORE_ATTR = Symbol(\"ignore\");\r\nconst ELEMENT_TRUE_VALUES = [true, 1, \"\", \"1\", \"true\"];\r\n\r\nconst ARRAY_EMPTY = [];\r\n\r\nconst NODE_TYPE = \"localName\";\r\n\r\nconst KEY = Symbol(\"key\");\r\n\r\nconst META_STYLE_SHEET = Symbol(\"styleSheet\");\r\n\r\nconst META_MAP_CHILDREN = Symbol(\"mapChildren\");\r\n\r\nconst META_KEYES = Symbol(\"keyes\");\r\n\r\nconst NODE_HOST = \"host\";\r\n\r\nconst IGNORE_CHILDREN = {\r\n    innerHTML: 1,\r\n    textContent: 1,\r\n    contenteditable: 1\r\n};\r\n\r\nconst JOIN_CHILDREN = {\r\n    style: 1,\r\n    children: 1\r\n};\r\n\r\nconst HYDRATE_PROPS = {\r\n    className: 1,\r\n    id: 1,\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1\r\n};\r\n\r\nconst CACHE_STYLE_SHEET = {};\r\n\r\nconst SUPPORT_STYLE_SHEET = \"adoptedStyleSheets\" in document;\r\n\r\nconst STYLE_SHEET_KEY = Symbol();\n\nexport { ARRAY_EMPTY as A, CACHE_STYLE_SHEET as C, ELEMENT_TRUE_VALUES as E, HOOK_CURRENT as H, IGNORE_CHILDREN as I, JOIN_CHILDREN as J, KEY as K, META_MAP_CHILDREN as M, NODE_HOST as N, SUPPORT_STYLE_SHEET as S, HOOK_MOUNT as a, HOOK_UPDATED as b, HOOK_MOUNTED as c, HOOK_UNMOUNT as d, HOOK_UPDATE as e, HYDRATE_PROPS as f, META_KEYES as g, META_STYLE_SHEET as h, STYLE_SHEET_KEY as i, NODE_TYPE as j, ELEMENT_IGNORE_ATTR as k, ELEMENT_PROPS as l };\n//# sourceMappingURL=constants.js.map\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nfunction isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nfunction isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isFunction(value) {\r\n    return typeof value == \"function\";\r\n}\r\n\r\n// export function fps(callback, count = 3) {\r\n//     count-- ? requestAnimationFrame(() => fps(callback, count)) : callback();\r\n// }\r\n\r\nfunction promise(callback) {\r\n    return new Promise(callback);\r\n}\n\nexport { isEqualArray as a, isArray as b, isFunction as i, promise as p };\n//# sourceMappingURL=utils.js.map\n","import { H as HOOK_CURRENT, a as HOOK_MOUNT, b as HOOK_UPDATED, c as HOOK_MOUNTED, d as HOOK_UNMOUNT, e as HOOK_UPDATE, A as ARRAY_EMPTY, I as IGNORE_CHILDREN, f as HYDRATE_PROPS, K as KEY, S as SUPPORT_STYLE_SHEET, C as CACHE_STYLE_SHEET, M as META_MAP_CHILDREN, g as META_KEYES, h as META_STYLE_SHEET, i as STYLE_SHEET_KEY, N as NODE_HOST, J as JOIN_CHILDREN, j as NODE_TYPE, E as ELEMENT_TRUE_VALUES, k as ELEMENT_IGNORE_ATTR, l as ELEMENT_PROPS } from './chunk/constants.js';\nimport { i as isFunction, a as isEqualArray, b as isArray, p as promise } from './chunk/utils.js';\n\nfunction update(hook, type) {\r\n    hook[0] && (hook[1] = hook[0](hook[1], type));\r\n}\r\n\r\nfunction updateAll(hooks, type) {\r\n    for (let i in hooks) update(hooks[i], type);\r\n}\r\n\r\nfunction useHook(reducer, initialState) {\r\n    if (HOOK_CURRENT.ref.hook) {\r\n        return HOOK_CURRENT.ref.hook.use(reducer, initialState)[1];\r\n    }\r\n}\r\n\r\nfunction useRender() {\r\n    return HOOK_CURRENT.ref.render;\r\n}\r\n\r\nfunction useHost() {\r\n    return useHook(0, { current: HOOK_CURRENT.ref.host });\r\n}\r\n\r\nfunction createHookCollection(render, host) {\r\n    let hooks = {};\r\n    let mounted;\r\n    let hook = {\r\n        use,\r\n        load,\r\n        updated,\r\n        unmount\r\n    };\r\n\r\n    let ref = { hook, host, render };\r\n\r\n    function load(callback, param) {\r\n        HOOK_CURRENT.index = 0;\r\n        HOOK_CURRENT.ref = ref;\r\n        let resolve = callback(param);\r\n        HOOK_CURRENT.ref = 0;\r\n        return resolve;\r\n    }\r\n    function use(reducer, state) {\r\n        let index = HOOK_CURRENT.index++;\r\n        let mount;\r\n        // record the hook and the initial state of this\r\n        if (!hooks[index]) {\r\n            hooks[index] = [null, state];\r\n            mount = 1;\r\n        }\r\n        // The hook always receives the last reduce.\r\n        hooks[index][0] = reducer;\r\n        update(hooks[index], mount ? HOOK_MOUNT : HOOK_UPDATE);\r\n        return hooks[index];\r\n    }\r\n    function updated() {\r\n        let type = mounted ? HOOK_UPDATED : HOOK_MOUNTED;\r\n        mounted = 1;\r\n        updateAll(hooks, type);\r\n    }\r\n    function unmount() {\r\n        updateAll(hooks, HOOK_UNMOUNT);\r\n    }\r\n    return hook;\r\n}\r\n\r\nfunction useState(initialState) {\r\n    let render = useRender();\r\n    return useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = isFunction(initialState) ? initialState() : initialState;\r\n            state[1] = nextState => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useEffect(callback, args) {\r\n    // define whether the effect in the render cycle should be regenerated\r\n    let executeEffect;\r\n    useHook((state, type) => {\r\n        if (executeEffect == null) {\r\n            executeEffect =\r\n                args && state[0] ? !isEqualArray(args, state[0]) : true;\r\n            state[0] = args;\r\n        }\r\n\r\n        switch (type) {\r\n            case HOOK_UPDATE:\r\n            case HOOK_UNMOUNT:\r\n                // save the current args, for comparison\r\n                if ((executeEffect || type == HOOK_UNMOUNT) && state[1]) {\r\n                    // compare the previous snapshot with the generated state\r\n                    state[1]();\r\n                    // clean the effect collector\r\n                    state[1] = 0;\r\n                }\r\n                // delete the previous argument for a hook\r\n                // run if the hook is inserted in a new node\r\n                // Why? ... to perform again dom operations associated with the parent\r\n                if (type == HOOK_UNMOUNT) {\r\n                    state[0] = null;\r\n                }\r\n                break;\r\n            case HOOK_MOUNTED:\r\n            case HOOK_UPDATED:\r\n                // save the current args, for comparison, repeats due to additional type HOOK_MOUNTED\r\n                if (executeEffect || type == HOOK_MOUNTED) {\r\n                    // save the effect collector\r\n                    state[1] = callback();\r\n                }\r\n                // save the comparison argument\r\n                break;\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useRef(current) {\r\n    return useHook(0, { current });\r\n}\r\n\r\nfunction useMemo(callback, args = ARRAY_EMPTY) {\r\n    let state = useHook(0, []);\r\n\r\n    if (!state[0] || (state[0] && !isEqualArray(state[0], args))) {\r\n        state[1] = callback();\r\n    }\r\n    state[0] = args;\r\n    return state[1];\r\n}\r\n\r\nfunction useReducer(reducer, initialState) {\r\n    let render = useRender();\r\n    let hook = useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = initialState;\r\n            state[1] = action => {\r\n                let nextState = state[2](state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n    // allows the reduce to always access the scope of the component\r\n    hook[2] = reducer;\r\n\r\n    return hook;\r\n}\r\n/**\r\n * @todo add test use callback\r\n */\r\nfunction useCallback(callback, args = ARRAY_EMPTY) {\r\n    return useMemo(() => callback, args);\r\n}\n\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {Object} handlers\r\n **/\r\nfunction diffProps(node, props, nextProps, isSvg, handlers) {\r\n    props = props || {};\r\n\r\n    for (let key in props) {\r\n        if (!(key in nextProps)) {\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n        }\r\n    }\r\n    let ignoreChildren;\r\n    for (let key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n        ignoreChildren = ignoreChildren || IGNORE_CHILDREN[key];\r\n    }\r\n    return ignoreChildren;\r\n}\r\n\r\nfunction setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && HYDRATE_PROPS[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue) return;\r\n\r\n    if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key, nextValue, handlers);\r\n        return;\r\n    }\r\n\r\n    switch (key) {\r\n        /**\r\n         * add support {@link https://developer.mozilla.org/es/docs/Web/API/CSSStyleSheet}\r\n         */\r\n        case \"styleSheet\":\r\n            if (SUPPORT_STYLE_SHEET)\r\n                node.shadowRoot.adoptedStyleSheets = []\r\n                    .concat(nextValue)\r\n                    .map(cssText => {\r\n                        if (cssText instanceof CSSStyleSheet) {\r\n                            return cssText;\r\n                        }\r\n                        if (!CACHE_STYLE_SHEET[cssText]) {\r\n                            CACHE_STYLE_SHEET[cssText] = new CSSStyleSheet();\r\n                            CACHE_STYLE_SHEET[cssText].replace(cssText);\r\n                        }\r\n\r\n                        return CACHE_STYLE_SHEET[cssText];\r\n                    });\r\n\r\n            break;\r\n        case \"ref\":\r\n            if (nextValue) nextValue.current = node;\r\n            break;\r\n        case \"style\":\r\n            setStyle(node, prevValue || \"\", nextValue || \"\");\r\n            break;\r\n        case \"key\":\r\n            node[KEY] = nextValue;\r\n            break;\r\n        default:\r\n            if (!isSvg && key != \"list\" && key in node) {\r\n                node[key] = nextValue == null ? \"\" : nextValue;\r\n            } else if (nextValue == null) {\r\n                node.removeAttribute(key);\r\n            } else {\r\n                node.setAttribute(\r\n                    key,\r\n                    typeof nextValue == \"object\"\r\n                        ? JSON.stringify(nextValue)\r\n                        : nextValue\r\n                );\r\n            }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {string} type\r\n * @param {function} [nextHandler]\r\n * @param {object} handlers\r\n */\r\nfunction setEvent(node, type, nextHandler, handlers) {\r\n    // get the name of the event to use\r\n    type = type.slice(type[2] == \"-\" ? 3 : 2);\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = event => handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            node.addEventListener(type, handlers);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n/**\r\n * define style as string inline,this generates less mutation\r\n * to the sun and cleans the previously defined properties.\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {(string|object)} prevValue\r\n * @param {(string|object)} nextValue\r\n */\r\nfunction setStyle(node, prevValue, nextValue) {\r\n    let style = node.style,\r\n        prevIsObject;\r\n    if (typeof prevValue == \"object\") {\r\n        prevIsObject = true;\r\n        for (let key in prevValue) {\r\n            if (!(key in nextValue)) setPropertyStyle(style, key, null);\r\n        }\r\n    }\r\n    if (typeof nextValue == \"object\") {\r\n        for (let key in nextValue) {\r\n            let value = nextValue[key];\r\n            if (prevIsObject && prevValue[key] === value) continue;\r\n            setPropertyStyle(style, key, value);\r\n        }\r\n    } else {\r\n        style.cssText = nextValue;\r\n    }\r\n}\r\n\r\nfunction setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\n\nlet vNodeEmpty = createElement(null, { children: \"\" });\r\n\r\n/**\r\n * @param {VnodeType} nodeType\r\n * @param {VnodeProps} [props]\r\n * @param {Vnode|Vnode[]} [children]\r\n * @returns {Vnode}\r\n **/\r\nfunction createElement(nodeType, props, ...children) {\r\n    let vnode = { children, ...props, nodeType: nodeType || null };\r\n    return vnode;\r\n}\r\n/**\r\n * toVnode, processes the object for correct use within the diff process.\r\n **/\r\nfunction toVnode(value) {\r\n    if (isVnodeValue(value)) {\r\n        return value;\r\n    } else {\r\n        if (!value[META_MAP_CHILDREN]) {\r\n            let scan = mapChildren(value.children);\r\n            value.children = scan.children;\r\n            if (scan.keyes) {\r\n                value[META_KEYES] = scan.keyes;\r\n            }\r\n            value[META_MAP_CHILDREN] = true;\r\n        }\r\n        if (value.styleSheet && !SUPPORT_STYLE_SHEET) {\r\n            if (!value[META_STYLE_SHEET]) {\r\n                value.children.unshift(\r\n                    toVnode(\r\n                        createElement(\r\n                            \"style\",\r\n                            value[META_KEYES] ? { key: STYLE_SHEET_KEY } : {},\r\n                            value.styleSheet\r\n                        )\r\n                    )\r\n                );\r\n                if (value[META_KEYES]) {\r\n                    value[META_KEYES].unshift(STYLE_SHEET_KEY);\r\n                }\r\n            }\r\n            value[META_STYLE_SHEET] = true;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mapChildren(children, scan = { children: [] }, deep = 0) {\r\n    if (isArray(children)) {\r\n        let length = children.length;\r\n        for (let i = 0; i < length; i++) {\r\n            mapChildren(children[i], scan, deep + 1);\r\n        }\r\n    } else {\r\n        if (children == null && !deep) return scan;\r\n\r\n        let vnode = toVnode(children);\r\n\r\n        if (vnode != null && typeof vnode == \"object\") {\r\n            if (isFunction(vnode.nodeType)) {\r\n                let { nodeType, ...props } = vnode;\r\n                return mapChildren(nodeType(props), scan, deep + 1);\r\n            }\r\n            if (\"key\" in vnode) {\r\n                scan.keyes = scan.keyes || [];\r\n                if (!~scan.keyes.indexOf(vnode.key)) {\r\n                    scan.keyes.push(vnode.key);\r\n                }\r\n            }\r\n        }\r\n\r\n        scan.children.push(vnode);\r\n    }\r\n    return scan;\r\n}\r\n\r\nfunction isVnodeEmpty(value) {\r\n    let type = typeof value;\r\n    return value == null || type == \"boolean\" || type == \"function\";\r\n}\r\n\r\nfunction fillVnodeValue(value) {\r\n    return isVnodeEmpty(value)\r\n        ? vNodeEmpty\r\n        : createElement(null, { children: \"\" + value });\r\n}\r\n\r\nfunction isVnodeValue(value) {\r\n    let type = typeof value;\r\n    return (\r\n        value == null ||\r\n        type == \"string\" ||\r\n        type == \"number\" ||\r\n        type == \"function\" ||\r\n        type == \"boolean\"\r\n    );\r\n}\r\n\r\n/**\r\n * @typedef {(Object<string,any>)} VnodeProps;\r\n *\r\n * @typedef {(Function|string)} VnodeType;\r\n *\r\n * @typedef {{type:VnodeType,props:VnodeProps}} Vnode\r\n **/\n\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {import(\"./vnode\").Vnode} nextVnode\r\n * @param {boolean} isSvg\r\n * @param {Function} currentUpdateComponent\r\n * @return {import(\"./render\").HTMLNode}\r\n **/\r\nfunction diff(id, node, nextVnode, isSvg) {\r\n    let { vnode, handlers = {} } = (node && node[id]) || {};\r\n\r\n    if (vnode == nextVnode && vnode != null) return node;\r\n\r\n    nextVnode = isVnodeValue(nextVnode) ? fillVnodeValue(nextVnode) : nextVnode;\r\n\r\n    let { nodeType, shadowDom, children, is, ...props } = vnode || {};\r\n\r\n    let {\r\n        nodeType: nextNodeType,\r\n        shadowDom: nextShadowDom,\r\n        children: nextChildren,\r\n        is: nextIs,\r\n        ...nextProps\r\n    } = nextVnode;\r\n\r\n    isSvg = isSvg || nextNodeType == \"svg\";\r\n\r\n    if (\r\n        nextNodeType != NODE_HOST &&\r\n        (getNodeName(node) !== nextNodeType || is != nextIs)\r\n    ) {\r\n        let nextNode = createNode(nextNodeType, isSvg, nextIs);\r\n        let parent = node && node.parentNode;\r\n\r\n        if (parent) {\r\n            parent.replaceChild(nextNode, node);\r\n        }\r\n\r\n        node = nextNode;\r\n        handlers = {};\r\n    }\r\n    if (JOIN_CHILDREN[nextNodeType]) {\r\n        nextNodeType = null;\r\n        nextChildren = nextChildren.join(\"\");\r\n    }\r\n    if (nextNodeType == null) {\r\n        if (node.textContent != nextChildren) {\r\n            node.textContent = nextChildren;\r\n        }\r\n    } else {\r\n        if (shadowDom != nextShadowDom) {\r\n            let { shadowRoot } = node;\r\n            let mode =\r\n                nextShadowDom && !shadowRoot\r\n                    ? \"open\"\r\n                    : !nextShadowDom && shadowRoot\r\n                    ? \"closed\"\r\n                    : 0;\r\n            if (mode) node.attachShadow({ mode });\r\n        }\r\n\r\n        let ignoreChildren = diffProps(\r\n            node,\r\n            props,\r\n            nextProps,\r\n            isSvg,\r\n            handlers);\r\n        if (!ignoreChildren && children != nextChildren) {\r\n            diffChildren(\r\n                id,\r\n                nextShadowDom ? node.shadowRoot : node,\r\n                nextChildren,\r\n                nextProps[META_KEYES],\r\n                isSvg\r\n            );\r\n        }\r\n    }\r\n    node[id] = { vnode: nextVnode, handlers };\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} parent\r\n * @param {import(\"./vnode\").Vnode[]} [nextChildren]\r\n * @param {boolean} isSvg\r\n */\r\nfunction diffChildren(id, parent, children, keyes, isSvg) {\r\n    let childrenLenght = children.length;\r\n    let { childNodes } = parent;\r\n    let childNodesKeyes = {};\r\n    let childNodesLength = childNodes.length;\r\n    let index = keyes\r\n        ? 0\r\n        : childNodesLength > childrenLenght\r\n        ? childrenLenght\r\n        : childNodesLength;\r\n\r\n    for (; index < childNodesLength; index++) {\r\n        let childNode = childNodes[index];\r\n        let key = index;\r\n        if (keyes) {\r\n            key = childNode[KEY];\r\n            if (keyes.indexOf(key) > -1) {\r\n                childNodesKeyes[key] = childNode;\r\n                continue;\r\n            }\r\n        }\r\n        index--;\r\n        childNodesLength--;\r\n        parent.removeChild(childNode);\r\n    }\r\n    for (let i = 0; i < childrenLenght; i++) {\r\n        let child = children[i];\r\n        let indexChildNode = childNodes[i];\r\n        let key = keyes ? child.key : i;\r\n        let childNode = keyes ? childNodesKeyes[key] : indexChildNode;\r\n\r\n        if (keyes && childNode) {\r\n            if (childNode != indexChildNode) {\r\n                parent.insertBefore(childNode, indexChildNode);\r\n            }\r\n        }\r\n\r\n        let nextChildNode = diff(id, childNode, child, isSvg);\r\n\r\n        if (!childNode) {\r\n            if (childNodes[i]) {\r\n                parent.insertBefore(nextChildNode, childNodes[i]);\r\n            } else {\r\n                parent.appendChild(nextChildNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} type\r\n * @param {boolean} isSvg\r\n * @returns {import(\"./render\").HTMLNode}\r\n */\r\nfunction createNode(type, isSvg, is) {\r\n    let doc = document;\r\n    let nextNode;\r\n    if (type != null) {\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", type)\r\n            : doc.createElement(type, is ? { is } : null);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    return nextNode;\r\n}\r\n\r\n/**\r\n * returns the localName of the node\r\n * @param {import(\"./render\").HTMLNode} node\r\n */\r\nfunction getNodeName(node) {\r\n    if (!node) return;\r\n    if (!node[NODE_TYPE]) {\r\n        node[NODE_TYPE] = node.nodeName.toLowerCase();\r\n    }\r\n    let localName = node[NODE_TYPE];\r\n    return localName == \"#text\" ? null : localName;\r\n}\n\nfunction render(vnode, node, id = \"vnode\") {\r\n    if (\r\n        vnode != null &&\r\n        typeof vnode == \"object\" &&\r\n        vnode.nodeType != NODE_HOST\r\n    ) {\r\n        vnode = createElement(NODE_HOST, { children: vnode });\r\n    }\r\n    vnode = toVnode(vnode);\r\n    diff(id, node, vnode);\r\n    return node;\r\n}\n\nfunction setAttr(node, attr, value) {\r\n    if (value == null) {\r\n        node.removeAttribute(attr);\r\n    } else {\r\n        node.setAttribute(\r\n            attr,\r\n            typeof value == \"object\" ? JSON.stringify(value) : value\r\n        );\r\n    }\r\n}\r\n\r\nfunction formatType(value, type = String) {\r\n    try {\r\n        if (type == Boolean) {\r\n            value = ELEMENT_TRUE_VALUES.indexOf(value) > -1;\r\n        } else if (typeof value == \"string\") {\r\n            value =\r\n                type == Number\r\n                    ? Number(value)\r\n                    : type == Object || type == Array\r\n                    ? JSON.parse(value)\r\n                    : type == Date\r\n                    ? new Date(value)\r\n                    : value;\r\n        }\r\n        if ({}.toString.call(value) == `[object ${type.name}]`) {\r\n            return { value, error: type == Number && Number.isNaN(value) };\r\n        }\r\n    } catch (e) {}\r\n\r\n    return { value, error: true };\r\n}\r\n\r\nfunction propToAttr(prop) {\r\n    return prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n}\r\n\r\nfunction attrToProp(attr) {\r\n    return attr.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nfunction dispatchEvent(node, type, customEventInit) {\r\n    node.dispatchEvent(\r\n        new CustomEvent(\r\n            type,\r\n            typeof customEventInit == \"object\" ? customEventInit : null\r\n        )\r\n    );\r\n}\n\nlet defer = Promise.resolve();\r\nlet queue = [];\r\nlet running;\r\n\r\nlet maxFps = 1000 / 60;\r\n\r\nconst IMPORTANT = Symbol(\"important\");\r\n\r\nfunction clearQueue() {\r\n    let time = performance.now();\r\n\r\n    let length = queue.length;\r\n    let current = queue;\r\n\r\n    queue = [];\r\n\r\n    while (length--) {\r\n        let callback = current[length];\r\n        if (callback[IMPORTANT] || performance.now() - time < maxFps) {\r\n            callback();\r\n        } else {\r\n            queue = queue.concat(current.slice(0, length + 1));\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (queue.length) {\r\n        requestAnimationFrame(clearQueue);\r\n        return;\r\n    }\r\n    running = false;\r\n}\r\n/**\r\n * add a task to the queue\r\n * @param {Function} callback\r\n * @returns {Promise} Generate a promise that show  if the queue is complete\r\n */\r\nfunction addQueue(callback) {\r\n    if (!running) {\r\n        running = true;\r\n        defer.then(clearQueue);\r\n    }\r\n    if (!queue.includes(callback)) queue.push(callback);\r\n}\n\nfunction load(self, componentRender, componentError) {\r\n    if (self.mount) return;\r\n\r\n    let id = Symbol(\"vnode\");\r\n\r\n    let isPrevent;\r\n    let isUnmount;\r\n\r\n    self[ELEMENT_PROPS] = {};\r\n\r\n    let isMounted;\r\n\r\n    let resolveUpdate;\r\n\r\n    let rerender = () => {\r\n        // disables blocking, allowing the cycle to be regenerate\r\n        isPrevent = false;\r\n        // After the first render it disables the important condition\r\n        if (rerender[IMPORTANT]) rerender[IMPORTANT] = false;\r\n        try {\r\n            render(\r\n                hooks.load(componentRender, { ...self[ELEMENT_PROPS] }),\r\n                self,\r\n                id\r\n            );\r\n\r\n            resolveUpdate();\r\n        } catch (e) {\r\n            (componentError || console.error)(e);\r\n        }\r\n    };\r\n    // mark the first render as important, self speeds up the rendering\r\n    rerender[IMPORTANT] = true;\r\n\r\n    self.update = () => {\r\n        if (isUnmount) return;\r\n        let rendered = self.rendered;\r\n        if (!isPrevent) {\r\n            isPrevent = true;\r\n            // create a promise to observe the status of the update\r\n            rendered = promise(resolve => (resolveUpdate = resolve)).then(\r\n                // the UPDATED state is only propagated through\r\n                // the resolution of the promise\r\n                // Why? ... to improve communication between web-component parent and children\r\n                hooks.updated\r\n            );\r\n\r\n            // if the component is already mounted, avoid using self.mounted,\r\n            // to speed up the microtask\r\n            isMounted\r\n                ? addQueue(rerender)\r\n                : self.mounted.then(() => {\r\n                      isMounted = true;\r\n                      addQueue(rerender);\r\n                  });\r\n        }\r\n\r\n        return (self.rendered = rendered);\r\n    };\r\n\r\n    // any update from hook is added to a separate queue\r\n    let hooks = createHookCollection(() => addQueue(self.update), self);\r\n\r\n    // creates a collection of microtask\r\n    // associated with the mounted of the component\r\n\r\n    self.mounted = promise(\r\n        resolve =>\r\n            (self.mount = () => {\r\n                isMounted = false;\r\n                // allows the reuse of the component when it is isUnmounted and mounted\r\n                if (isUnmount == true) {\r\n                    isUnmount = false;\r\n                    self.mounted = self.update();\r\n                }\r\n                resolve();\r\n            })\r\n    );\r\n    /**\r\n     * creates a collection of microtask\r\n     * associated with the unmounted of the component\r\n     */\r\n    self.unmounted = promise(\r\n        resolve =>\r\n            (self.unmount = () => {\r\n                isUnmount = true;\r\n                hooks.unmount();\r\n                resolve();\r\n            })\r\n    );\r\n\r\n    self.initialize();\r\n\r\n    self.update();\r\n}\r\n\r\n/**\r\n * register the component, be it a class or function\r\n * @param {string} nodeType\r\n * @param {Function} component\r\n * @return {Function} returns a jsx component\r\n */\r\nfunction customElement(nodeType, component, options) {\r\n    if (isFunction(nodeType)) {\r\n        // By defining nodeType as a function, custom ELement\r\n        // allows the assignment of a constructor to be extended\r\n        let BaseElement = component || HTMLElement;\r\n\r\n        component = nodeType;\r\n\r\n        let { props, error } = component;\r\n\r\n        /**@type {Function[]}*/\r\n        let initialize = [];\r\n\r\n        /**@type {string[]} */\r\n        let attrs = [];\r\n\r\n        let CustomElement = class extends BaseElement {\r\n            constructor() {\r\n                super();\r\n                /**\r\n                 * identifier to store the virtual-dom state,\r\n                 * this is unique between instances of the\r\n                 * component to securely consider the host status\r\n                 */\r\n                load(this, component, error);\r\n            }\r\n            connectedCallback() {\r\n                load(this, component, error);\r\n                this.mount();\r\n            }\r\n            disconnectedCallback() {\r\n                this.unmount();\r\n            }\r\n            attributeChangedCallback(attr, oldValue, value) {\r\n                if (attr === this[ELEMENT_IGNORE_ATTR] || oldValue === value)\r\n                    return;\r\n                this[attrToProp(attr)] = value;\r\n            }\r\n            initialize() {\r\n                let length = initialize.length;\r\n                while (length--) initialize[length](this);\r\n            }\r\n        };\r\n\r\n        let prototype = CustomElement.prototype;\r\n\r\n        for (let prop in props)\r\n            setProperty$1(prototype, initialize, attrs, prop, props[prop]);\r\n\r\n        CustomElement.observedAttributes = attrs;\r\n\r\n        return CustomElement;\r\n    } else {\r\n        let { base, ...opts } = options || {};\r\n\r\n        customElements.define(nodeType, customElement(component, base), opts);\r\n\r\n        return props => createElement(nodeType, props);\r\n    }\r\n}\r\n\r\nfunction setProperty$1(prototype, initialize, attrs, prop, schema) {\r\n    let attr = propToAttr(prop);\r\n\r\n    schema = schema.name ? { type: schema } : schema;\r\n\r\n    // avoid rewriting the prototype\r\n    if (prop in prototype) return;\r\n\r\n    function set(nextValue) {\r\n        let prevValue = this[ELEMENT_PROPS][prop];\r\n\r\n        if (isFunction(nextValue)) {\r\n            nextValue = nextValue(prevValue);\r\n        }\r\n        let { value, error } = formatType(nextValue, schema.type);\r\n\r\n        if (error && value != null) {\r\n            throw `the observable [${prop}] must be of the type [${schema.type.name}]`;\r\n        }\r\n\r\n        if (prevValue == value) return;\r\n\r\n        this[ELEMENT_PROPS][prop] = value;\r\n\r\n        let rendered = this.update();\r\n\r\n        if (schema.event) {\r\n            // The event is only dispatched if the component has finished\r\n            // the rendering cycle, this is useful to observe the changes\r\n            rendered.then(() =>\r\n                dispatchEvent(this, schema.event.type || prop, schema.event)\r\n            );\r\n        }\r\n\r\n        if (schema.reflect) {\r\n            // the default properties are only reflected once the web-component is mounted\r\n            this.mounted.then(() => {\r\n                this[ELEMENT_IGNORE_ATTR] = attr; //update is prevented\r\n                setAttr(\r\n                    this,\r\n                    attr,\r\n                    schema.type == Boolean && !value ? null : value //\r\n                );\r\n                this[ELEMENT_IGNORE_ATTR] = false; // an upcoming update is allowed\r\n            });\r\n        }\r\n    }\r\n\r\n    function get() {\r\n        return this[ELEMENT_PROPS][prop];\r\n    }\r\n\r\n    Object.defineProperty(prototype, prop, { set, get });\r\n\r\n    if (\"value\" in schema) {\r\n        initialize.push(self => (self[prop] = schema.value));\r\n    }\r\n    attrs.push(attr);\r\n}\n\nfunction useProp(name) {\r\n    let ref = useHost();\r\n    if (name in ref.current) {\r\n        if (!ref[name]) {\r\n            ref[name] = [null, nextValue => (ref.current[name] = nextValue)];\r\n        }\r\n        ref[name][0] = ref.current[name];\r\n        return ref[name];\r\n    }\r\n}\r\n\r\nfunction useEvent(type, customEventInit) {\r\n    let ref = useHost();\r\n    if (!ref[type]) {\r\n        ref[type] = detail =>\r\n            dispatchEvent(\r\n                ref.current,\r\n                type,\r\n                detail ? { ...customEventInit, detail } : customEventInit\r\n            );\r\n    }\r\n    return ref[type];\r\n}\r\n\r\nfunction usePublic(name, value) {\r\n    let { current } = useHost();\r\n    if (current[name] != value) {\r\n        current[name] = value;\r\n    }\r\n    return current[name];\r\n}\n\nexport { createHookCollection, customElement, createElement as h, render, toVnode, useCallback, useEffect, useEvent, useHook, useHost, useMemo, useProp, usePublic, useReducer, useRef, useRender, useState };\n//# sourceMappingURL=core.js.map\n","import { h, customElement, useEffect, useHost } from \"atomico\";\r\n\r\nfunction eventRedirect(window) {\r\n  window.dispatchEvent(new PopStateEvent(\"popstate\"));\r\n}\r\n\r\nfunction Microfront({ options, props }) {\r\n  let ref = useHost();\r\n\r\n  useEffect(() => {\r\n    let { contentDocument, contentWindow } = ref.current;\r\n\r\n    if (!ref.load) {\r\n      let script = document.createElement(\"script\");\r\n      /**\r\n       * HACK, the use of code split, improves the micro frontend experience,\r\n       * since it allows to assimilate the execution of the application in a\r\n       * sandbox, this leaves the task of synchronizing with history\r\n       */\r\n      script.textContent = `window.$ =(${options.source})().then(md=>md.default)`;\r\n\r\n      contentDocument.body.appendChild(script);\r\n\r\n      // let { history: sandboxHistory } = contentWindow;\r\n      // let { root } = props;\r\n      // sandboxHistory.pushState = function(state, title, path) {\r\n      //   /**\r\n      //    * @todo find a way to synchronize the status of the iframe route\r\n      //    **/\r\n      //   pushState.call(this, state, title, \"/sandbox\" + path);\r\n      //   history.pushState(state, title, path);\r\n      //   eventRedirect(contentWindow);\r\n      // };\r\n\r\n      ref.load = true;\r\n    }\r\n    contentWindow.$.then(component => {\r\n      options.render(contentDocument.body, component, props);\r\n    });\r\n  }, [props]);\r\n\r\n  useEffect(() => {\r\n    let { contentDocument } = ref.current;\r\n    return () => options.render(contentDocument.body, null, null);\r\n  }, []);\r\n\r\n  return (\r\n    <host\r\n      sandbox=\"allow-same-origin allow-scripts allow-popups allow-forms\"\r\n      frameBorder=\"0\"\r\n    ></host>\r\n  );\r\n}\r\n\r\nMicrofront.props = {\r\n  options: Object,\r\n  props: Object\r\n};\r\n\r\nexport default customElement(\"atomico-microfront\", Microfront, {\r\n  base: HTMLIFrameElement,\r\n  extends: \"iframe\"\r\n});\r\n","import \"./microfront\";\r\nimport { h } from \"atomico\";\r\nimport { render as preactRender, h as createElement } from \"preact\";\r\n/**\r\n *\r\n * @param {Function} source - function to insert as string in the sandbox\r\n * @param {*} options -\r\n */\r\nexport function preact(source, options) {\r\n  options = {\r\n    ...options,\r\n    source,\r\n    /**\r\n     *\r\n     * @param {HTMLBodyElement} node\r\n     * @param {Function} component\r\n     * @param {?Object} props - if null indicates that the component has been unmounted\r\n     */\r\n    render(node, component, props) {\r\n      preactRender(props ? createElement(component, props) : \"\", node);\r\n    }\r\n  };\r\n  return props => (\r\n    <iframe is=\"atomico-microfront\" options={options} props={props}></iframe>\r\n  );\r\n}\r\n","import { h, customElement } from \"atomico\";\r\nimport { preact } from \"./microfront\";\r\n\r\nlet Component = preact(() => import(\"./preact/example\"));\r\n\r\nfunction MyApp() {\r\n  return (\r\n    <host>\r\n      Atomico containers\r\n      <Component></Component>\r\n    </host>\r\n  );\r\n}\r\n\r\ncustomElement(\"my-app\", MyApp);\r\n"],"names":["Microfront","options","props","ref","useHost","useEffect","contentDocument","contentWindow","current","load","script","document","createElement","textContent","source","body","appendChild","$","then","component","render","h","Object","customElement","base","HTMLIFrameElement","extends","preact","node","preactRender","Component","MyApp"],"mappings":";;AAAY,MAAC,UAAU,GAAG,MAAM,CAAC,OAAD,CAApB;AACA,MAAC,YAAY,GAAG,MAAM,CAAC,SAAD,CAAtB;AACA,MAAC,WAAW,GAAG,MAAM,CAAC,QAAD,CAArB;AACA,MAAC,YAAY,GAAG,MAAM,CAAC,SAAD,CAAtB;AACA,MAAC,YAAY,GAAG,MAAM,CAAC,SAAD,CAAtB;AACA,MAAC,YAAY,GAAG,EAAhB;AAEA,MAAC,aAAa,GAAG,MAAM,CAAC,OAAD,CAAvB;AACA,MAAC,mBAAmB,GAAG,MAAM,CAAC,QAAD,CAA7B;AACA,MAAC,mBAAmB,GAAG,CAAC,IAAD,EAAO,CAAP,EAAU,EAAV,EAAc,GAAd,EAAmB,MAAnB,CAAvB;AAEA,AAEA,MAAC,SAAS,GAAG,WAAb;AAEA,MAAC,GAAG,GAAG,MAAM,CAAC,KAAD,CAAb;AAEA,MAAC,gBAAgB,GAAG,MAAM,CAAC,YAAD,CAA1B;AAEA,MAAC,iBAAiB,GAAG,MAAM,CAAC,aAAD,CAA3B;AAEA,MAAC,UAAU,GAAG,MAAM,CAAC,OAAD,CAApB;AAEA,MAAC,SAAS,GAAG,MAAb;AAEA,MAAC,eAAe,GAAG;EAC3B,SAAS,EAAE,CADgB;EAE3B,WAAW,EAAE,CAFc;EAG3B,eAAe,EAAE;CAHT;AAMA,MAAC,aAAa,GAAG;EACzB,KAAK,EAAE,CADkB;EAEzB,QAAQ,EAAE;CAFF;AAKA,MAAC,aAAa,GAAG;EACzB,SAAS,EAAE,CADc;EAEzB,EAAE,EAAE,CAFqB;EAGzB,OAAO,EAAE,CAHgB;EAIzB,KAAK,EAAE,CAJkB;EAKzB,QAAQ,EAAE;CALF;AAQA,MAAC,iBAAiB,GAAG,EAArB;AAEA,MAAC,mBAAmB,GAAG,wBAAwB,QAA/C;AAEA,MAAC,eAAe,GAAG,MAAM,EAAzB;;AChDZ;;;;;AAKO,SAAS,OAAT,CAAiB,KAAjB,EAAwB;SACpB,KAAK,CAAC,OAAN,CAAc,KAAd,CAAP;;;;;;;;;;;;;;;AAaG,SAAS,YAAT,CAAsB,MAAtB,EAA8B,KAA9B,EAAqC;MACpC,MAAM,GAAG,MAAM,CAAC,MAApB;MACI,MAAM,KAAK,KAAK,CAAC,MAArB,EAA6B,OAAO,KAAP;;OACxB,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,CAAC,EAA7B,EAAiC;QACzB,MAAM,CAAC,CAAD,CAAN,KAAc,KAAK,CAAC,CAAD,CAAvB,EAA4B,OAAO,KAAP;;;SAEzB,IAAP;;;AAWG,SAAS,UAAT,CAAoB,KAApB,EAA2B;SACvB,OAAO,KAAP,IAAgB,UAAvB;;;;;;AAOG,SAAS,OAAT,CAAiB,QAAjB,EAA2B;SACvB,IAAI,OAAJ,CAAY,QAAZ,CAAP;;;AClCJ,SAAS,MAAT,CAAgB,IAAhB,EAAsB,IAAtB,EAA4B;EACxB,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAI,CAAC,CAAD,CAAJ,CAAQ,IAAI,CAAC,CAAD,CAAZ,EAAiB,IAAjB,CAAtB;;;AAGJ,SAAS,SAAT,CAAmB,KAAnB,EAA0B,IAA1B,EAAgC;OACvB,IAAI,CAAT,IAAc,KAAd,EAAqB,MAAM,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,IAAX,CAAN;;;AAGlB,SAAS,OAAT,CAAiB,OAAjB,EAA0B,YAA1B,EAAwC;MACvC,YAAY,CAAC,GAAb,CAAiB,IAArB,EAA2B;WAChB,YAAY,CAAC,GAAb,CAAiB,IAAjB,CAAsB,GAAtB,CAA0B,OAA1B,EAAmC,YAAnC,EAAiD,CAAjD,CAAP;;;;AAQD,SAAS,OAAT,GAAmB;SACf,OAAO,CAAC,CAAD,EAAI;IAAE,OAAO,EAAE,YAAY,CAAC,GAAb,CAAiB;GAAhC,CAAd;;;AAGG,SAAS,oBAAT,CAA8B,MAA9B,EAAsC,IAAtC,EAA4C;MAC3C,KAAK,GAAG,EAAZ;MACI,OAAJ;MACI,IAAI,GAAG;IACP,GADO;IAEP,IAFO;IAGP,OAHO;IAIP;GAJJ;MAOI,GAAG,GAAG;IAAE,IAAF;IAAQ,IAAR;IAAc;GAAxB;;WAES,IAAT,CAAc,QAAd,EAAwB,KAAxB,EAA+B;IAC3B,YAAY,CAAC,KAAb,GAAqB,CAArB;IACA,YAAY,CAAC,GAAb,GAAmB,GAAnB;QACI,OAAO,GAAG,QAAQ,CAAC,KAAD,CAAtB;IACA,YAAY,CAAC,GAAb,GAAmB,CAAnB;WACO,OAAP;;;WAEK,GAAT,CAAa,OAAb,EAAsB,KAAtB,EAA6B;QACrB,KAAK,GAAG,YAAY,CAAC,KAAb,EAAZ;QACI,KAAJ,CAFyB;;QAIrB,CAAC,KAAK,CAAC,KAAD,CAAV,EAAmB;MACf,KAAK,CAAC,KAAD,CAAL,GAAe,CAAC,IAAD,EAAO,KAAP,CAAf;MACA,KAAK,GAAG,CAAR;KANqB;;;IASzB,KAAK,CAAC,KAAD,CAAL,CAAa,CAAb,IAAkB,OAAlB;IACA,MAAM,CAAC,KAAK,CAAC,KAAD,CAAN,EAAe,KAAK,GAAG,UAAH,GAAgB,WAApC,CAAN;WACO,KAAK,CAAC,KAAD,CAAZ;;;WAEK,OAAT,GAAmB;QACX,IAAI,GAAG,OAAO,GAAG,YAAH,GAAkB,YAApC;IACA,OAAO,GAAG,CAAV;IACA,SAAS,CAAC,KAAD,EAAQ,IAAR,CAAT;;;WAEK,OAAT,GAAmB;IACf,SAAS,CAAC,KAAD,EAAQ,YAAR,CAAT;;;SAEG,IAAP;;;AAsBG,SAAS,SAAT,CAAmB,QAAnB,EAA6B,IAA7B,EAAmC;;MAElC,aAAJ;EACA,OAAO,CAAC,CAAC,KAAD,EAAQ,IAAR,KAAiB;QACjB,aAAa,IAAI,IAArB,EAA2B;MACvB,aAAa,GACT,IAAI,IAAI,KAAK,CAAC,CAAD,CAAb,GAAmB,CAAC,YAAY,CAAC,IAAD,EAAO,KAAK,CAAC,CAAD,CAAZ,CAAhC,GAAmD,IADvD;MAEA,KAAK,CAAC,CAAD,CAAL,GAAW,IAAX;;;YAGI,IAAR;WACS,WAAL;WACK,YAAL;;YAEQ,CAAC,aAAa,IAAI,IAAI,IAAI,YAA1B,KAA2C,KAAK,CAAC,CAAD,CAApD,EAAyD;;UAErD,KAAK,CAAC,CAAD,CAAL,GAFqD;;UAIrD,KAAK,CAAC,CAAD,CAAL,GAAW,CAAX;SANR;;;;;YAWQ,IAAI,IAAI,YAAZ,EAA0B;UACtB,KAAK,CAAC,CAAD,CAAL,GAAW,IAAX;;;;;WAGH,YAAL;WACK,YAAL;;YAEQ,aAAa,IAAI,IAAI,IAAI,YAA7B,EAA2C;;UAEvC,KAAK,CAAC,CAAD,CAAL,GAAW,QAAQ,EAAnB;SAJR;;;;;;WASG,KAAP;GAlCG,EAmCJ,EAnCI,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FJ,SAASA,UAAT,CAAoB;EAAEC,OAAF;EAAWC;CAA/B,EAAwC;MAClCC,GAAG,GAAGC,OAAO,EAAjB;EAEAC,SAAS,CAAC,MAAM;QACV;MAAEC,eAAF;MAAmBC;QAAkBJ,GAAG,CAACK,OAA7C;;QAEI,CAACL,GAAG,CAACM,IAAT,EAAe;UACTC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAb;;;;;;;MAMAF,MAAM,CAACG,WAAP,wBAAmCZ,OAAO,CAACa,MAA3C;MAEAR,eAAe,CAACS,IAAhB,CAAqBC,WAArB,CAAiCN,MAAjC,EATa;;;;;;;;;;;MAsBbP,GAAG,CAACM,IAAJ,GAAW,IAAX;;;IAEFF,aAAa,CAACU,CAAd,CAAgBC,IAAhB,CAAqBC,SAAS,IAAI;MAChClB,OAAO,CAACmB,MAAR,CAAed,eAAe,CAACS,IAA/B,EAAqCI,SAArC,EAAgDjB,KAAhD;KADF;GA3BO,EA8BN,CAACA,KAAD,CA9BM,CAAT;EAgCAG,SAAS,CAAC,MAAM;QACV;MAAEC;QAAoBH,GAAG,CAACK,OAA9B;WACO,MAAMP,OAAO,CAACmB,MAAR,CAAed,eAAe,CAACS,IAA/B,EAAqC,IAArC,EAA2C,IAA3C,CAAb;GAFO,EAGN,EAHM,CAAT;SAMEM;IACE,OAAO,EAAC,0DADV;IAEE,WAAW,EAAC;IAHhB;;;AAQFrB,UAAU,CAACE,KAAX,GAAmB;EACjBD,OAAO,EAAEqB,MADQ;EAEjBpB,KAAK,EAAEoB;CAFT;AAKA,AAAeC,aAAa,CAAC,oBAAD,EAAuBvB,UAAvB,EAAmC;EAC7DwB,IAAI,EAAEC,iBADuD;EAE7DC,OAAO,EAAE;CAFiB,CAA5B;;ACxDA;;;;;;AAKA,AAAO,SAASC,MAAT,CAAgBb,MAAhB,EAAwBb,OAAxB,EAAiC;EACtCA,OAAO,GAAG,EACR,GAAGA,OADK;IAERa,MAFQ;;;;;;;;IASRM,MAAM,CAACQ,IAAD,EAAOT,SAAP,EAAkBjB,KAAlB,EAAyB;MAC7B2B,CAAY,CAAC3B,KAAK,GAAGU,CAAa,CAACO,SAAD,EAAYjB,KAAZ,CAAhB,GAAqC,EAA3C,EAA+C0B,IAA/C,CAAZ;;;GAVJ;SAaO1B,KAAK,IACVmB;IAAQ,EAAE,EAAC,oBAAX;IAAgC,OAAO,EAAEpB,OAAzC;IAAkD,KAAK,EAAEC;IAD3D;;;ACnBF,IAAI4B,SAAS,GAAGH,MAAM,CAAC,MAAM,OAAO,sBAAP,CAAP,CAAtB;;AAEA,SAASI,KAAT,GAAiB;SAEbV,kDAEEA,cAAC,SAAD,OAFF,CADF;;;AAQFE,aAAa,CAAC,QAAD,EAAWQ,KAAX,CAAb"}